#include "StdAfx.h"
#include "AudioBang.h"
#include "Signature.h"
#include "resource.h"

using namespace Eyw;

////////////////////////////////////////////////////////////////////////////////////
// Signature
Eyw::block_class_registrant g_AudioBang( 
	Eyw::block_class_registrant::block_id( "AudioBang" )
		.begin_language( EYW_LANGUAGE_US_ENGLISH )
			.name( "AudioBang" )
			.description( "Build 1.0.3.22\nGenerate a trigger output when audio crosses threhold level.\n"
							"Utilises audio threshold crossing for trigger output, rangeGate for length of period to search for threshold. \n"
							"Added clockTrigger to bypass threshold check and allow trigger to be generated by using rangeGate as a seconds timer.\n"
							"This block requires an audio in source." )
			.libraries( "OSL" )
			.bitmap( IDB_AUDIOBANG_BITMAP )
		.end_language()	
		.begin_authors()
			.author( EYW_OSL_LIGHT_CATALOG_AUTHOR_ID )
		.end_authors()
		.begin_companies()
			.company( EYW_OSL_LIGHT_COMPANY_ID )
		.end_companies()
		.begin_licences()
			.licence( EYW_OSL_LIGHT_LICENSE_ID )
		.end_licences()
		.default_factory< CAudioBang >()
	);

//////////////////////////////////////////////////////////////////////
// Identifiers
#define PARAMETER_INTHRESHOLD "inThreshold"
#define PARAMETER_INRANGEGATE "inRangeGate"
#define PARAMETER_BOOLTRIGGER "clockTrigger"

#define INPUT_INAUDIO "inAudio"
#define OUTPUT_OUTAUDIO "outAudio"
#define OUTPUT_OUTTRIGGER "outTrigger"


/////////////////////////////////
CAudioBang::CAudioBang( const Eyw::OBJECT_CREATIONCTX* ctxPtr )
:	Eyw::CBlockImpl( ctxPtr )
{
	_pInAudio = NULL;
	_pOutTrigger = NULL;
	_pOutAudio = NULL;

	_schedulingInfoPtr->SetActivationEventBased( true );
	_schedulingInfoPtr->GetEventBasedActivationInfo()->SetActivationOnInputChanged( INPUT_INAUDIO, true );
}

CAudioBang::~CAudioBang()
{
}

void CAudioBang::InitSignature()
{
	_pParamInThreshold= Eyw::Cast<Eyw::IDouble*>(
	                     SetParameter(Eyw::pin::id(PARAMETER_INTHRESHOLD)
	                         .name("inThreshold")
	                         .description("threshold value to cross")
	                         .type<Eyw::IDouble>()
							 .set_double_domain(true)
							 .min(0.0, true)
							 .max(1.0, true)
	                         )->GetDatatype() );
	_pParamRangeGate= Eyw::Cast<Eyw::IInt*>(
	                     SetParameter(Eyw::pin::id(PARAMETER_INRANGEGATE)
	                         .name("inRangeGate")
	                         .description("Range limit of period to search for threshold, or timer for sending trigger")
	                         .type<Eyw::IInt>()
							 .set_int_domain(true)
							 .min(2, true)
							 .max(150, true)
	                         )->GetDatatype() );

	SetParameter(Eyw::pin::id(PARAMETER_BOOLTRIGGER)
		.name("clockTrigger")
		.description("Use clock trigger (true) or threshold trigger (false).")
		.type<Eyw::IBool>()
		);

	SetInput(Eyw::pin::id(INPUT_INAUDIO)
	    .name("inAudio")
	    .description("audio source")
	    .type<Eyw::IAudioBuffer>()
	    );
	SetOutput( Eyw::pin::id(OUTPUT_OUTAUDIO)
		.name( "outAudio" )
		.description( "output audio monitor" )
		.type<IAudioBuffer>()
		);

	SetOutput(Eyw::pin::id(OUTPUT_OUTTRIGGER)
	    .name("outTrigger")
	    .description("threshold generated trigger")
	    .type<Eyw::ITrigger>()
	    );

	_pParamInThreshold->SetValue( 0.5 );
	_pParamRangeGate->SetValue( 25 );
}

void CAudioBang::CheckSignature()
{
	_pParamInThreshold = get_parameter_datatype<Eyw::IDouble>(PARAMETER_INTHRESHOLD);
	_pParamRangeGate = get_parameter_datatype<Eyw::IInt>(PARAMETER_INRANGEGATE);

	_pBoolTrigger = get_parameter_datatype<Eyw::IBool>(PARAMETER_BOOLTRIGGER);

	_signaturePtr->GetInputs()->FindItem( INPUT_INAUDIO );
	_signaturePtr->GetOutputs()->FindItem( OUTPUT_OUTTRIGGER );
}

void CAudioBang::DoneSignature()
{
	_pParamInThreshold = NULL;
	_pParamRangeGate = NULL;
	_pBoolTrigger = NULL;

}

// Actions
bool CAudioBang::Init() throw()
{
    try
    {
		_pInAudio = get_input_datatype<Eyw::IAudioBuffer>( INPUT_INAUDIO );
		inAudioInitInfo = Eyw::datatype_init_info<Eyw::IAudioBufferInitInfo>::create( _kernelServicesPtr );
		inAudioInitInfo->CopyFrom( _pInAudio->GetInitInfo() );

		_pOutAudio = get_output_datatype<IAudioBuffer>( OUTPUT_OUTAUDIO );
		outAudioInitInfo = datatype_init_info<IAudioBufferInitInfo>::create( _kernelServicesPtr );

		copy_datatype_init_info( outAudioInitInfo, inAudioInitInfo );

		//outAudioInitInfo->_samplingRate = 22050.0;
		//outAudioInitInfo->_nSamples = 512;
		//outAudioInitInfo->_nChannels = 2;

		_pOutAudio->InitInstance( outAudioInitInfo.get() );

		inAudioSamplingRate = inAudioInitInfo->_samplingRate;
		inAudioNumSamples = inAudioInitInfo->_nSamples;	
		inAudioNumChannels = inAudioInitInfo->_nChannels;

		_pOutTrigger = get_output_datatype<Eyw::ITrigger>( OUTPUT_OUTTRIGGER );
		clockTrigger = _pBoolTrigger->GetValue() == 1;

		
		//SetMinimumPhysicalBufferDuration
		//Eyw::IDSoundInputDevice...
		//soundDevice->InitInstance("default"); // CSTR szDeviceID,  call it our own name.
		//soundDeviceInitInfo = datatype_init_info<IDSoundInputDevice>::create( _kernelServicesPtr );
		//soundDevice->InitInstance("default"); // CSTR szDeviceID,  call it our own name.
		/*
		soundDevicePtr->InitInstance("default");
		// IBlockActivationRequest* blockActivationRequest
		soundDevicePtr->Init( NULL );
		soundDevicePtr->SetNumChannels( 2 );
		soundDevicePtr->SetSamplingRate( 22050 );
		soundDevicePtr->SetMaximumDelay( 0 );
		soundDevicePtr->SetMinimumPhysicalBufferDuration( 20000000 ); // 2 secs
		soundDevicePtr->SetMaximumDelay( 2500000 ); // 250ms
		soundDevicePtr-SetBufferSize( 512 );
		*/

    	return true;
    }
    catch(...)
    {
        return false;
    }
}

bool CAudioBang::Start() throw()
{
    try
    {
		paramThreshold = 0.5;
		timer = 0;
		rangeCounter = 0;
		rangeGate = 25;
		rangeTimer = 0;

		//soundDevicePtr->StartCapture();

    	return true;
    }
    catch(...)
    {
        return false;
    }
}

bool CAudioBang::Execute() throw()
{
    try
    {
		rangeCounter++;

		paramThreshold = _pParamInThreshold->GetValue();
		if (paramThreshold < 0.0 || paramThreshold > 1.0) {
			// invalid value
			paramThreshold = 0.5;
		}

// Clock Trigger : run every second based upon rangeGate value
		if (clockTrigger) {
			if (rangeCounter == rangeGate) {
				_pOutTrigger->SetCreationTime( _clockPtr->GetTime() );
			}
		}

// Range Counter : run every second frame
		else {
			if (rangeCounter % 2 == 0) {
				for( int c = 0; c < inAudioInitInfo->_nChannels; ++c ) {
					double* channelPtr = _pInAudio->GetChannel( c );
				
					for( int s = 0; s < inAudioNumSamples; ++s ) {
						if (channelPtr[s] > paramThreshold ) {
							_pOutTrigger->SetCreationTime( _clockPtr->GetTime() );
						}
					}
				}
			}
		}

		// limit the counter
		if (rangeCounter > rangeGate) {
			rangeCounter = 0;
		}

    	// straight copy for testing:
		_pOutAudio->CopyFrom( _pInAudio.get() );
		_pOutAudio->SetCreationTime( _clockPtr->GetTime() );
    }
    catch(...)
    {
    }
	return true;
}

void CAudioBang::OnChangedParameter(const std::string &parameterId)
{
	if (parameterId == PARAMETER_INRANGEGATE) {
		rangeGate = _pParamRangeGate->GetValue();
	
		if (rangeGate < 2 || rangeGate > 150) {
			// invalid value
			Notify_MessageString( "\nAudioBang block: rangeGate invalid value, set to default 25.\n" );
			rangeGate = 25;
		}
	}
	else if ( parameterId == PARAMETER_BOOLTRIGGER ) {
		clockTrigger = _pBoolTrigger->GetValue();
	}
	else
	{
		Eyw::CBlockImpl::OnChangedParameter(parameterId);
	}
}


void CAudioBang::Stop() throw()
{
    try
    {
		rangeCounter = 0;
		//soundDevicePtr->StopCapture();
    }
    catch(...)
    {
    }
}

void CAudioBang::Done() throw()
{
    try
    {
		_pInAudio = NULL;
		_pOutAudio = NULL;
		_pOutTrigger = NULL;
		
		//soundDevicePtr->Done();

    }
    catch(...)
    {
    }
}
